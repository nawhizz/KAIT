#include <sqlhdr.h>
#include <sqliapi.h>
#line 1 "testsvr1.ec"
#include <stdio.h>
#include <ctype.h>
#include <usrinc/atmi.h>	
#include <usrinc/fbuf.h>
#include "../fdl/demo_fdl.h"

/* 
 * EXEC SQL include sqlca.h;
 */
#line 7 "testsvr1.ec"

#line 7 "testsvr1.ec"
#line 1 "/informix/incl/esql/sqlca.h"
/***************************************************************************
 *
 *			   INFORMIX SOFTWARE, INC.
 *
 *			      PROPRIETARY DATA
 *
 *	THIS DOCUMENT CONTAINS TRADE SECRET DATA WHICH IS THE PROPERTY OF
 *	INFORMIX SOFTWARE, INC.  THIS DOCUMENT IS SUBMITTED TO RECIPIENT IN
 *	CONFIDENCE.  INFORMATION CONTAINED HEREIN MAY NOT BE USED, COPIED OR
 *	DISCLOSED IN WHOLE OR IN PART EXCEPT AS PERMITTED BY WRITTEN AGREEMENT
 *	SIGNED BY AN OFFICER OF INFORMIX SOFTWARE, INC.
 *
 *	THIS MATERIAL IS ALSO COPYRIGHTED AS AN UNPUBLISHED WORK UNDER
 *	SECTIONS 104 AND 408 OF TITLE 17 OF THE UNITED STATES CODE.
 *	UNAUTHORIZED USE, COPYING OR OTHER REPRODUCTION IS PROHIBITED BY LAW.
 *
 *
 *  Title:	sqlca.h
 *  Sccsid:	@(#)sqlca.h	9.4	1/18/93  11:09:48
 *  Description:
 *		SQL Control Area
 *
 ***************************************************************************
 */

#ifndef SQLCA_INCL
#define SQLCA_INCL

#include "ifxtypes.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct sqlca_s
    {
    int4 sqlcode;
    char sqlerrm[72]; /* error message parameters */
    char sqlerrp[8];
    int4 sqlerrd[6];
		    /* 0 - estimated number of rows returned */
		    /* 1 - serial value after insert or  ISAM error code */
		    /* 2 - number of rows processed */
		    /* 3 - estimated cost */
		    /* 4 - offset of the error into the SQL statement */
		    /* 5 - rowid after insert  */
#ifdef _FGL_
    char sqlawarn[8];
#else
    struct sqlcaw_s
	{
	char sqlwarn0; /* = W if any of sqlwarn[1-7] = W */
	char sqlwarn1; /* = W if any truncation occurred or
				database has transactions or
			        no privileges revoked */
	char sqlwarn2; /* = W if a null value returned or
				ANSI database */
	char sqlwarn3; /* = W if no. in select list != no. in into list or
				turbo backend or no privileges granted */
	char sqlwarn4; /* = W if no where clause on prepared update, delete or
				incompatible float format */
	char sqlwarn5; /* = W if non-ANSI statement */
	char sqlwarn6; /* = W if server is in data replication secondary mode */
	char sqlwarn7; /* = W if database locale is different from proc_locale
			*/
	} sqlwarn;
#endif
    } ifx_sqlca_t;

/* NOTE: 4gl assumes that the sqlwarn structure can be defined as
 *	sqlawarn -- an 8 character string, because single-char
 *	variables are not recognized in 4gl.
 *
 * If this structure should change, the code generated by 4gl compiler
 *	must also change
 */

#ifdef VMS
noshare
#endif /* VMS */

#define SQLNOTFOUND 100

#ifndef IFX_THREAD
extern struct sqlca_s sqlca;

extern int4 SQLCODE;

extern char SQLSTATE[];
#else /* IFX_THREAD */
extern int4 * ifx_sqlcode();
extern struct sqlca_s * ifx_sqlca();
#define SQLCODE (*(ifx_sqlcode()))
#define SQLSTATE ((char *)(ifx_sqlstate()))
#define sqlca (*(ifx_sqlca()))
#endif /* IFX_THREAD */

#ifdef __cplusplus
}
#endif

#endif /* SQLCA_INCL */

#line 103 "/informix/incl/esql/sqlca.h"
#line 8 "testsvr1.ec"

/*
 * exec sql begin declare section;
 */
#line 9 "testsvr1.ec"
#line 10 "testsvr1.ec"
#line 10 "testsvr1.ec"
int col1;
#line 11 "testsvr1.ec"
int col2;
/*
 * exec sql end declare section;
 */
#line 12 "testsvr1.ec"

/*
FEBISSVC(TPSVCINFO *msg)
{
	FBUF *sndbuf;
	char tmpbuf[256];	
	int  i,loop;

	loop = atoi(msg->data);

	fprintf(stderr, "loop ---> [%d]\n", loop);

	if ((sndbuf = (FBUF *)tpalloc("FIELD",0,1000*3000)) == NULL){
		fprintf(stderr, "sndbuf tpalloc failed[%d]\n",tperrno);
		tpreturn(TPFAIL, -1, NULL, 0, 0);
	}
	for( i=0; i< loop; i++){
		memset(tmpbuf, 0x00, sizeof(tmpbuf));	
		sprintf(tmpbuf, "[%d]%s",i,"th data" );
		fprintf(stderr, "tmpbuf---> [%s]\n",tmpbuf);
		fbput( sndbuf, FML_1, (char *)tmpbuf, 0 );
		fbput( sndbuf, FML_2, (char *)tmpbuf, 0 );
		fbput( sndbuf, FML_3, (char *)tmpbuf, 0 );
		fbput( sndbuf, FML_4, (char *)tmpbuf, 0 );
		fbput( sndbuf, FML_5, (char *)tmpbuf, 0 );
		fbput( sndbuf, FML_6, (char *)tmpbuf, 0 );
		fbput( sndbuf, FML_7, (char *)tmpbuf, 0 );
		fbput( sndbuf, FML_8, (char *)tmpbuf, 0 );
		fbput( sndbuf, FML_9, (char *)tmpbuf, 0 );
	}	
	tpreturn(TPSUCCESS, 0, (char *)sndbuf, 0, 0);	
}
*/
FEBISSVC(TPSVCINFO *msg)
{

	char *rcvbuf;
	long rlen;

	col1 = atoi(msg->data);
	col2 = col1 + 100;

/*
 * 	EXEC SQL insert into test values( :col1,:col2);
 */
#line 54 "testsvr1.ec"
  {
#line 54 "testsvr1.ec"
  static const char *sqlcmdtxt[] =
#line 54 "testsvr1.ec"
    {
#line 54 "testsvr1.ec"
    " insert into test values ( ? , ? )",
    0
    };
#line 54 "testsvr1.ec"
  static ifx_statement_t _SQ0 = {0};
  static ifx_sqlvar_t _sqibind[] = 
    {
      { 102, sizeof(col1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 102, sizeof(col2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
#line 54 "testsvr1.ec"
    };
#line 54 "testsvr1.ec"
#line 54 "testsvr1.ec"
  _sqibind[0].sqldata = (char *) &col1;
#line 54 "testsvr1.ec"
  _sqibind[1].sqldata = (char *) &col2;
  sqli_stmt(ESQLINTVERSION, &_SQ0, (char **) sqlcmdtxt, 2, _sqibind, (struct value *) 0, (ifx_literal_t *) 0, (ifx_namelist_t *) 0, (ifx_cursor_t *) 0, 6, 0, 0);
#line 54 "testsvr1.ec"
  }

	if (sqlca.sqlcode != 0)
		tpreturn(TPFAIL,sqlca.sqlcode, NULL, 0, 0);

/*
	rcvbuf = tpalloc("STRING", NULL, 0);

	if (tpcall("TESTSVC2", msg->data, 0, &rcvbuf, &rlen, 0) <0){
		fprintf(stdout, "MEMTESTNXA service tpcall failed[%d]\n",tperrno );
		tpreturn(TPFAIL,sqlca.sqlcode, NULL, 0, 0);
	}
	if (tpcall("MEMTESTNXA", msg->data, 0, &rcvbuf, &rlen, 0) <0){
		fprintf(stdout, "MEMTESTNXA service tpcall failed[%d]\n",tperrno );
		tpreturn(TPFAIL,sqlca.sqlcode, NULL, 0, 0);
	}
*/
	tpreturn(TPSUCCESS, 0, NULL, 0, 0);			
}

TESTSVC1(TPSVCINFO *msg)		
{
    char *msgdata;
    int  ins_count, i;
    long lsndlen, lrcvlen;
    char return_val[10];

    col1 = atoi(msg->data);
    col2 = col1 + 200;

    printf("testsvr1 : col2 [%d] \n", col2);

    tx_begin();

/*
 *     EXEC SQL
 *     INSERT INTO test VALUES (:col1,:col2);
 */
#line 88 "testsvr1.ec"
  {
#line 89 "testsvr1.ec"
  static const char *sqlcmdtxt[] =
#line 89 "testsvr1.ec"
    {
#line 89 "testsvr1.ec"
    " INSERT INTO test VALUES ( ? , ? )",
    0
    };
#line 89 "testsvr1.ec"
  static ifx_statement_t _SQ0 = {0};
  static ifx_sqlvar_t _sqibind[] = 
    {
      { 102, sizeof(col1), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 102, sizeof(col2), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
#line 89 "testsvr1.ec"
    };
#line 89 "testsvr1.ec"
#line 89 "testsvr1.ec"
  _sqibind[0].sqldata = (char *) &col1;
#line 89 "testsvr1.ec"
  _sqibind[1].sqldata = (char *) &col2;
  sqli_stmt(ESQLINTVERSION, &_SQ0, (char **) sqlcmdtxt, 2, _sqibind, (struct value *) 0, (ifx_literal_t *) 0, (ifx_namelist_t *) 0, (ifx_cursor_t *) 0, 6, 0, 0);
#line 89 "testsvr1.ec"
  }

    if (sqlca.sqlcode != 0){
        printf("update error sqlerror=%d",sqlca.sqlcode);
        tpreturn(TPFAIL, sqlca.sqlcode, (char *)NULL, 0, 0);
    }

    if (tpcall( "TESTSVC2", msg->data, 0, (char **)&msg->data, (long *)&lrcvlen, 0) < 0){
        printf("tpcall TESTSVC2=%d, %d",tperrno, tpurcode);
	tx_rollback();
        tpreturn(TPFAIL, tpurcode, (char *)NULL, 0, 0);
    }
    sleep(30);
    tx_commit();
	
    tpreturn(TPSUCCESS, 1000, (char *)NULL, 0, 0);
}
tpsvctimeout(TPSVCINFO *msg)
{
	if(sqldone() == -439)
        {
            printf("[%s] TIMEOUT : SQLCODE[%d] ISAMERR[%d] SqlBreakCode[%d]\n",msg->name ,sqlca.sqlcode,sqlca.sqlerrd[1],sqlbreak());
        }
        else {
            printf("[%s] TIMEOUT : SQLCODE[%d] ISAMERR[%d]\n",msg->name ,sqlca.sqlcode,sqlca.sqlerrd[1]);
            tpreturn(TPFAIL, -1, (char *)msg->data, 0, 0);
        }

/*
	tpreturn(TPEXIT, -444, (char *)NULL, 0, 0);
*/
}



#line 122 "testsvr1.ec"
